/*Nabil Ahmed
	ID: 25364170	
	Calculating the number of events in an MPI process where random number is generated by each nodes and if the random number generated by the neighboring nodes are the same then an an event is triggered 
	The program logic is explained in the pdf file
*/
#include <stdlib.h>
#include <time.h>
#include <stdio.h>
#include "mpi.h"

int randomNumber(int lower, int upper);
int neighbourRanks(int rank, int neighbours[4]);

void main(int argc,char **argv){
	int i;
	int j;
	int k;
	int r;  //random number container
	int neighbours[4] = {-1,-1,-1,-1};
	int size, rank;
	
	//Initializing the MPI world
	MPI_Init(&argc,&argv);
	//Number of processors
	MPI_Comm_size(MPI_COMM_WORLD,&size);
	//Rank of the Process
	MPI_Comm_rank(MPI_COMM_WORLD,&rank);
	
	//Process 1-20 ... Process 0 is the Base Station
	if (rank != 0){
		//For generating random number at each iteration
		srand(time(NULL) | rank);
		//nSize
		int num_of_neighbours;
		//Total number of neighbours for this process
		num_of_neighbours = neigh_bour(rank, neighbours);
		//Do 1000 iterations i.e. 20 nodes will generate the random numbers 1000 times
		for(i = 0; i < 1000; i++){
			r = randomNumber(0, 9);
			
			int req; 
			req = 0;

			//For both ISend and IRecv twice the size is required
			MPI_Status	statuses[num_of_neighbours * 2];			
			MPI_Request requests[num_of_neighbours * 2];
			
			//Random numbers of the neighbours  
			int rand_neighbour[num_of_neighbours];				
			for (j = 0; j < num_of_neighbours; j++){
				//Non blocking send to adjacent nodes
				//dest : neighbours
				//buffer: random number generated
				// tag = 0
				//datatype = MPI_INT				
				MPI_Isend(&r,1, MPI_INT,neighbours[j],0,MPI_COMM_WORLD,&requests[req]);
				req++;
			}

			for (j = 0; j < num_of_neighbours; j++){
				//Non blocking receive from adjacent nodes
				//source : neighbours
				//buffer: neighbours containing the random numbers
				// tag = 0
				//datatype=MPI_INT
				MPI_Irecv(&rand_neighbour[j],1,MPI_INT,neighbours[j],0,MPI_COMM_WORLD,&requests[req]);
				req++;
				
			}
			MPI_Waitall(num_of_neighbours * 2,requests,statuses);
				
			for(k=0; k< num_of_neighbours; k++){
				printf("rank: %d random number generated by the adj_nodes: %d \n",rank, rand_neighbour[k]);
			}
		}			
	}	
	MPI_Finalize();
}


int randomNumber(int lower, int upper){
	//Returns: A random number generated by the given equation
	int num;
	num = (rand() % (upper-lower +1)) + lower;
	return num;
}


int neigh_bour(int rank, int neighbours[4]){
	/*Func: neigh_bour computes all the adjacent nodes of a given node
		param1: int
		param2: array
		returns: total number of neighbours
		*/
	int c = 0;	
	if (rank + 5 <= 20){
		neighbours[c] = rank + 5;
		c++;	
	}
	if (rank - 5 > 0){
		neighbours[c] = rank - 5;
		c++;	
	}
	
	if ((rank-1) % 5 != 0 && rank - 1  > 0){
		neighbours[c] = rank - 1;
		c++;			
	}
	if (rank % 5 != 0 && rank + 1 <= 20){
		neighbours[c] = rank + 1;
		c++;			
	}	
	return c;
}

/*************************************THE END**********************************************/
